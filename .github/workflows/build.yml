name: Build AutoHotkey Script (with Enhanced Debugging)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest

    steps:
    # الخطوة 1: الحصول على الكود
    - name: Checkout code
      uses: actions/checkout@v4

    # الخطوة 2: تثبيت نواة AutoHotkey
    - name: Install AutoHotkey Core
      shell: pwsh
      run: |
        $setupUrl = "https://github.com/AutoHotkey/AutoHotkey/releases/download/v2.0.19/AutoHotkey_2.0.19_setup.exe"
        $setupFile = "AutoHotkey_setup.exe"
        Invoke-WebRequest -Uri $setupUrl -OutFile $setupFile
        Start-Process -FilePath $setupFile -ArgumentList "/silent /elevate" -Wait

    # الخطوة 3: تثبيت المحول Ahk2Exe (مع تعديل السكربت ليصبح صامتاً)
    - name: Install Compiler (and Patch Script)
      shell: pwsh
      run: |
        $installScriptPath = "C:\Program Files\AutoHotkey\UX\install-version.ahk"

        Write-Output "Patching '$installScriptPath' to remove ONLY the final MsgBox..."
        
        # === الكود الجديد لتحديد وحذف السطر الأخير فقط ===
        # نقرأ الملف كمصفوفة من السطور
        $lines = Get-Content -Path $installScriptPath
        
        # نبحث عن رقم السطر الأخير الذي يحتوي على كلمة MsgBox
        $lastMatchIndex = -1
        for ($i = 0; $i -lt $lines.Count; $i++) {
            if ($lines[$i] -like '*MsgBox*') {
                $lastMatchIndex = $i
            }
        }
        
        # إذا وجدنا سطراً مطابقاً، نقوم بحذفه (عبر جعله فارغاً)
        if ($lastMatchIndex -ne -1) {
            Write-Output "Found MsgBox on line $($lastMatchIndex + 1). Removing it."
            $lines[$lastMatchIndex] = ""
        }
        
        # نحفظ الملف مرة أخرى بعد إزالة السطر
        Set-Content -Path $installScriptPath -Value $lines
        # =======================================================

        Write-Output "Script patched successfully. Now running the installer..."

        $interpreterPath = "C:\Program Files\AutoHotkey\v2\AutoHotkey.exe"
        Start-Process -FilePath $interpreterPath -ArgumentList "/script `"$installScriptPath`"" -Wait
        Write-Output "Secondary installation complete."

    - name: Debug and Compile with Enhanced Error Handling
      shell: pwsh
      run: |
        $compilerFolder = "C:\Program Files\AutoHotkey\Compiler"
        $compilerExe = "$compilerFolder\Ahk2Exe.exe"
        $sourceFile = "$($env:GITHUB_WORKSPACE)\Playback.ahk"
        $iconFile = "$($env:GITHUB_WORKSPACE)\play_pause_icon_137298.ico"
        $outputFile = "$($env:GITHUB_WORKSPACE)\Playback.exe"

        # === حلقة التحقق مع مؤقت التي طلبتها ===
        Write-Output "Verifying compiler installation by waiting for folder: '$compilerFolder'..."
        $timeoutSeconds = 60
        $intervalSeconds = 5
        $timer = [System.Diagnostics.Stopwatch]::StartNew()
        
        while (-not (Test-Path $compilerFolder)) {
            if ($timer.Elapsed.TotalSeconds -ge $timeoutSeconds) {
                throw "Timeout! Compiler folder not found at '$compilerFolder' after $timeoutSeconds seconds."
            }
            Write-Output "Compiler folder not found. Waiting for $intervalSeconds seconds before checking again..."
            Start-Sleep -Seconds $intervalSeconds
        }
        $timer.Stop()
        Start-Sleep -Seconds 20
        Write-Output "Success! Compiler folder found in $($timer.Elapsed.TotalSeconds) seconds."
        # ==========================================

        # === التحقق من وجود الملفات المطلوبة ===
        Write-Output "=== Pre-compilation Checks ==="
        Write-Output "Checking source file: '$sourceFile'"
        if (-not (Test-Path $sourceFile)) {
            throw "ERROR: Source file 'Playback.ahk' not found!"
        }
        Write-Output "✓ Source file found"

        Write-Output "Checking icon file: '$iconFile'"
        if (-not (Test-Path $iconFile)) {
            Write-Output "⚠ Warning: Icon file not found, compilation will proceed without icon"
            $iconFile = $null
        } else {
            Write-Output "✓ Icon file found"
        }

        Write-Output "Checking compiler executable: '$compilerExe'"
        if (-not (Test-Path $compilerExe)) {
            throw "ERROR: Compiler executable not found at '$compilerExe'"
        }
        Write-Output "✓ Compiler executable found"

        # === عرض محتوى أول 20 سطر من الملف المصدري للتشخيص ===
        Write-Output "=== Source File Preview (First 20 lines) ==="
        $sourceContent = Get-Content -Path $sourceFile -TotalCount 20
        for ($i = 0; $i -lt $sourceContent.Count; $i++) {
            Write-Output "Line $($i + 1): $($sourceContent[$i])"
        }
        Write-Output "=== End of Preview ==="

        # === بناء أمر التحويل ===
        $compilerArgs = @("/in", "`"$sourceFile`"", "/out", "`"$outputFile`"")
        if ($iconFile) {
            $compilerArgs += "/icon", "`"$iconFile`""
        }

        Write-Output "=== Starting Compilation ==="
        Write-Output "Compiler: $compilerExe"
        Write-Output "Arguments: $($compilerArgs -join ' ')"

        # === تشغيل المحول مع التقاط الأخطاء التفصيلية ===
        try {
            $process = Start-Process -FilePath $compilerExe -ArgumentList $compilerArgs -NoNewWindow -Wait -PassThru -RedirectStandardOutput "compiler_output.txt" -RedirectStandardError "compiler_error.txt"
            $exitCode = $process.ExitCode
            
            Write-Output "=== Compilation Results ==="
            Write-Output "Exit Code: $exitCode"
            
            # عرض مخرجات المحول
            if (Test-Path "compiler_output.txt") {
                $output = Get-Content "compiler_output.txt" -Raw
                if ($output.Trim()) {
                    Write-Output "=== Compiler Output ==="
                    Write-Output $output
                }
            }
            
            # عرض أخطاء المحول
            if (Test-Path "compiler_error.txt") {
                $errorOutput = Get-Content "compiler_error.txt" -Raw
                if ($errorOutput.Trim()) {
                    Write-Output "=== Compiler Errors ==="
                    Write-Output $errorOutput
                }
            }
            
            # التحقق من نجاح التحويل
            if ($exitCode -ne 0) {
                throw "Ahk2Exe.exe failed with exit code $exitCode. Check the error messages above."
            }
            
        } catch {
            Write-Output "=== Exception during compilation ==="
            Write-Output $_.Exception.Message
            throw "Compilation failed: $($_.Exception.Message)"
        }

        # === التحقق النهائي من وجود الملف الناتج ===
        if (-not (Test-Path $outputFile)) {
            # عرض محتويات المجلد لمساعدة التشخيص
            Write-Output "=== Directory Contents for Debugging ==="
            Get-ChildItem -Path $env:GITHUB_WORKSPACE | ForEach-Object {
                Write-Output "$($_.Name) - Size: $($_.Length) bytes"
            }
            throw "VERIFICATION FAILED! The output file was not found after compilation."
        }
        
        $outputFileInfo = Get-Item $outputFile
        Write-Output "SUCCESS! Compiled file created at '$outputFile'"
        Write-Output "File size: $($outputFileInfo.Length) bytes"
        Write-Output "Created: $($outputFileInfo.CreationTime)"
              
    # الخطوة 5: رفع الملف التنفيذي الناتج
    - name: Upload executable
      uses: actions/upload-artifact@v4
      with:
        name: Compiled-Program
        path: Playback.exe
        
    # خطوة إضافية: رفع ملفات التشخيص في حال الفشل
    - name: Upload debug files (if they exist)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: Debug-Files
        path: |
          compiler_output.txt
          compiler_error.txt
        if-no-files-found: ignore